---
layout: post
title: "mysql"
date: 2019-01-20
description: "复习MySQL"
tag: 复习
---
<h3>1.数据库访问的优化法则</h3>
<h4>总体概述</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;1.减少磁盘访问：减少数据库的访问。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;2.减少网络传输：返回更少数据，减少交互次数。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;3.减少CPU及内存开销：减少服务器CPU开销。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;4.增加资源：利用更多资源。
</p>
<h4>1.减少数据库的访问</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;创建并使用正确的索引；只通过索引访问数据；优化sql执行计划。
</p>
<h4>2.返回更少的数据，减少交互次数</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;数据分页处理：客户端分页、服务端分页、数据库sql分页。只返回需要的字段。减少交互次数：对增删改进行批处理，使用存储过程、优化业务逻辑。
</p>
<h4>3.减少服务器CPU开销</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;大量复杂运算在客户端处理、使用绑定变量、合理使用排序、减少比较操作。
</p>
<h4>4.利用等多的资源</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;客户端多进程访问、数据库并行处理。
</p>
<h3>2.Mysql 的存储引擎,myisam和innodb的区别</h3>
<h4>1.二者区别</h4>
<p style="margin-left: 2%;">&nbsp;&nbsp;&nbsp;&nbsp;MyISAM 是非事务的存储引擎，适合用于频繁查询的应用。表锁，不会出现死锁，适合小并发。<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;innodb是支持事务的存储引擎，合于插入和更新操作比较多的应用，设计合理的话是行锁（最大区别就在锁的级别上），适合大并发。<br/>
</p>
<h4>2. innodb引擎的4大特性</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;插入缓冲（insert buffer)；二次写(double write)；自适应哈希索引(ahi)；预读(read ahead)。
</p>
<h4>3.2者select count(*)哪个更快，为什么</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;myisam更快，因为myisam内部维护了一个计数器，可以直接调取。
</p>
<h4>4. 2者的索引的实现方式</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;都是 B+树索引， Innodb 是索引组织表， myisam 是堆表， 索引组织表和堆表的区别要熟悉
</p>
<h3>3.如何进行SQL优化</h3>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;（1）选择正确的存储引擎。以 MySQL为例，包括有两个存储引擎 MyISAM 和 InnoDB，每个引擎都有利有弊。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;（2）优化字段的数据类型。记住一个原则，越小的列会越快。例如使用 MEDIUMINT, SMALLINT 或是更小的 TINYINT 会比int更经济一些；如果你不需要记录时间，使用 DATE 要比 DATETIME 好得多。当然，你也需要留够足够的扩展空间。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;（3）为搜索字段添加索引。如果在你的表中，有某个字段你总要会经常用来做搜索，那么最好是为其建立索引，除非你要搜索的字段是大的文本字段，那应该建立全文索引。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;（4）避免使用Select *从数据库里读出越多的数据。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;（5）使用 ENUM 而不是 VARCHAR。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;（6）尽可能的使用 NOT NULL。NULL其实需要额外的空间，并且，在你进行比较的时候，你的程序会更复杂。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;（7）固定长度的表会更快。如果表中的所有字段都是“固定长度”的，整个表会被认为是 “static” 或 “fixed-length”。
</p>
<h3>4.实践中如何优化MySQL</h3>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;① SQL语句及索引的优化；<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;② 数据库表结构的优化；<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;③ 系统配置的优化；<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;④ 硬件的优化。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.cnblogs.com/easypass/archive/2010/12/08/1900127.html">链接参考</a>
</p>
<h3>5.索引</h3>
<h4>1.索引的定义和作用</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。索引可以极大的提高数据的查询速度，但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件。
</p>
<h4>2.索引的底层实现原理</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;经过优化的B+树。主要是在所有的叶子结点中增加了指向下一个叶子节点的指针，因此InnoDB建议为大部分表使用默认自增的主键作为主索引。
</p>
<h4>3.什么情况下设置了索引但无法使用 </h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;① 以“%”开头的LIKE语句，模糊匹配。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;② OR语句前后没有同时使用索引。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;③ 数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;④ 索引无法存储null值。查询时，采用is null条件时，不能利用到索引，只能全表扫描。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;⑤ 不适合键值较少的列（重复数据较多的列）。
</p>
<h3>6.sql优化实际操作</h3>
<h4>1.explain出来的各种item的意义</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;id:每个被独立执行的操作的标志，表示对象被操作的顺序。一般来说， id 值大，先被执行；如果 id 值相同，则顺序从上到下。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;select_type：查询中每个 select 子句的类型。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;table:名字，被操作的对象名称，通常的表名(或者别名)，但是也有其他格式。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;partitions:匹配的分区信息。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;type:join 类型。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;possible_keys：列出可能会用到的索引。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;key:实际用到的索引。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;key_len:用到的索引键的平均长度，单位为字节。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;ref:表示本行被操作的对象的参照对象，可能是一个常量用 const 表示，也可能是其他表的。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;key 指向的对象，比如说驱动表的连接列。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;rows:估计每次需要扫描的行数。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;filtered:rows*filtered/100 表示该步骤最后得到的行数(估计值)。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;extra:重要的补充信息
</p>
<h4>2.profile的意义以及使用场景</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;Profile 用来分析 sql 性能的消耗分布情况。当用 explain 无法解决慢 SQL 的时候，需要用profile 来对 sql 进行更细致的分析，找出 sql 所花的时间大部分消耗在哪个部分，确认 sql的性能瓶颈。
</p>
<h4>6.explain 中的索引问题</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;Explain 结果中，一般来说，要看到尽量用 index(type为const、ref等，key列有值)，避免使用全表扫描(type 显式为 ALL)。比如说有 where 条件且选择性不错的列，需要建立索引。
	被驱动表的连接列，也需要建立索引。被驱动表的连接列也可能会跟 where 条件列一起建立联合索引。当有排序或者 group by 的需求时，也可以考虑建立索引来达到直接排序和汇总的需求。
</p>
<h3>7.MySQL中varchar与char的区别以及varchar(50)中的50代表的涵义</h3>
<h4>1.varchar与char的区别</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;在单字节字符集下， char（ N） 在内部存储的时候总是定长， 而且没有变长字段长度列表中。 在多字节字符集下面， char(N)如果存储的字节数超过 N，那么 char（ N）将和 varchar（ N）没有区别。在多字节字符集下面，如果存
	储的字节数少于 N，那么存储 N 个字节，后面补空格，补到 N 字节长度。 都存储变长的数据和变长字段长度列表。 varchar(N)无论是什么字节字符集，都是变长的，即都存储变长数据和变长字段长度列表。
</p>
<h4>2.varchar(50)中50的涵义</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)。在早期 MySQL 版本中， 50 代表字节数，现在代表字符数。
</p>
<h4>3.int（20）中20的涵义</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;是指显示字符的长度。不影响内部存储，只是影响带 zerofill 定义的 int 时，前面补多少个 0，易于报表展示。
</p>
<h4>4.mysql为什么这么设计</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;对大多数应用没有意义，只是规定一些工具用来显示字符的个数；int(1)和int(20)存储和计算均一样。
</p>
<h3>8.事务</h3>
<h4>1.事务的定义</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;事务：是一系列的数据库操作，是数据库应用的基本逻辑单位。可以这么理解：事务就是被绑定在一起作为一个逻辑工作单元的SQL语句分组，如果任何一个语句操作失败那么整个操作就被失败，以后操作就会回滚到操作前状态，或者是上有个节点。
	他有四大特性（ACID）：原子性、一致性、隔离性、持久性。
</p>
<h4>2.MySQL 中 InnoDB 支持的四种事务隔离级别名称</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;读未提交(read uncommitted)、读已提交(read committed)、可重复读(repeatable read)、串行(serializable)。
</p>
<h4>3.不同隔离级别之间的现象</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;Read Uncommitted:可以读取其他 session 未提交的脏数据。会出现脏读、不可重复读、幻读；<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;Read Committed:提交后，其他会话可以看到提交的数据。不会出现脏读，会出现不可重复读、幻读；<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;Repeatable Read: 不会出现脏读、不可重复读、会出现幻读(innodb 独有)。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;Serializable: 事务只能一个接着一个地执行，但不能并发执行。事务隔离级别最高。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;不同的隔离级别有不同的现象，并有不同的锁定/并发机制，隔离级别越高，数据库的并发性就越差。<br/>
</p>
<h3>9.参考链接</h3>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.cnblogs.com/lijiasnong/p/9963905.html">最全MYSQL面试题和答案</a><br/>
	&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.cnblogs.com/easypass/archive/2010/12/08/1900127.html">数据库访问性能优化</a><br/>
	&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.cnblogs.com/youngerger/p/8633074.html">MYSQL经典面试题</a><br/>
	&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://blog.sina.com.cn/s/blog_14e19d5f50102x6b3.html">JAVA程序员面试两年经验必问题</a>
</p>
