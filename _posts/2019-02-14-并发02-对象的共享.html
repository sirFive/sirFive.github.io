---
layout: post
title: "对象的共享"
date: 2019-02-14
description: "Java并发编程实战--对象的共享"
tag: Java并发编程实战
---
<h3>1.可见性</h3>
<h4>1.可见性的定义</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;当一个线程修改了对象状态后，其它线程能够看到发生的状态变化。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。
</p>
<h4>2.失效数据</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;在缺乏同步的过程中可能产生失效数据：当线程A读取线程变量A时，可能有另一个线程已经修改了它，线程A读到的就是过期的数据。
</p>
<h4>3.非原子的64位操作</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;最低安全性：在线程没有同步的情况下读取变量时，可能会得到一个失效值，但这个值至少是由之前某个线程设置的值，而不是一个随机值。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;非volatile类型的64位数值变量（double和long），JVM允许将64位的读操作或者写操作分解为两个32位的操作，因此可能会出现读或者写高32位和低32位的时候不是同一个值。
</p>
<h4>4.加锁与可见性</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;内置锁可以用于确保某个线程以一种可预测的方式来查看另一个线程的执行结果。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。
</p>
<h4>5.volatile变量</h4>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;volatile变量是一种稍弱的同步机制，用于确保变量的更新操作通知到其它线程，而且声明为volatile变量后它就是一个共享的变量，不会缓存到寄存器或者其它处理器不可见的地方。</br>
	&nbsp;&nbsp;&nbsp;&nbsp;从内存的可见性角度来看，写入volatile变量相当于退出同步代码块，而读取volatile变量相当于进入同步代码块。
</p>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;注意：加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;使用volatile变量的条件：<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;1.对变量的写入操作不依赖变量当前的值，或者你能确保只有单个线程更新变量的值；<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;2.该变量不会与其它变量一起纳入不变性条件中；<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;3.在访问变量时不需要加锁。
</p>

<h3>2.发布与逸出</h3>
<p style="margin-left: 2%;">
	&nbsp;&nbsp;&nbsp;&nbsp;未完待续。。。
</p>

